package menu;

import controller.OrderController;
import model.Order;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.sql.Date;
import java.util.List;
import java.util.Scanner;

public class OrderMenu {
    public static void orderMenu(Scanner scanner) {
        OrderController controller = new OrderController();

        while (true) {
            System.out.println("\n=== Order menu ===");
            System.out.println("1. Add Order");
            System.out.println("2. Update Order");
            System.out.println("3. Delete Order");
            System.out.println("4. View Orders");
            System.out.println("5. View Order by ID");
            System.out.println("0. Back");
            System.out.print("Choose an option: ");
            String line = scanner.nextLine().trim();
            int choice;
            try {
                choice = Integer.parseInt(line);
            } catch (Exception e) {
                System.out.println("Invalid input.");
                continue;
            }

            try {
                if (choice == 1) {
                    Integer id = readIntOptional(scanner, "Order ID (leave blank if none): ");
                    System.out.print("Order Date (yyyy-mm-dd): ");
                    Date date = Date.valueOf(scanner.nextLine().trim());
                    int customerId = readIntRequired(scanner, "Order Customer ID: ");
                    System.out.print("Order Status: ");
                    String status = scanner.nextLine();
                    Order order = buildOrder(id, date, customerId, status);
                    if (order != null && controller.insertOrder(order)) {
                        System.out.println("Added successfully.");
                    } else {
                        System.out.println("Add failed.");
                    }
                } else if (choice == 2) {
                    int id = readIntRequired(scanner, "Order ID to update: ");
                    System.out.print("New Order Date (yyyy-mm-dd): ");
                    Date date = Date.valueOf(scanner.nextLine().trim());
                    int customerId = readIntRequired(scanner, "New Order Customer ID: ");
                    System.out.print("New Order Status: ");
                    String status = scanner.nextLine();
                    Order order = buildOrder(id, date, customerId, status);
                    if (order != null && controller.updateOrder(order)) {
                        System.out.println("Updated successfully.");
                    } else {
                        System.out.println("Update failed.");
                    }
                } else if (choice == 3) {
                    int id = readIntRequired(scanner, "Order ID to delete: ");
                    boolean ok = controller.deleteOrder(id);
                    System.out.println(ok ? "Deleted successfully." : "Delete failed.");
                } else if (choice == 4) {
                    List<Order> list = controller.getAllOrders();
                    printHeader();
                    if (list != null) {
                        for (Order o : list) printRow(o);
                    }
                    printFooter();
                } else if (choice == 5) {
                    int id = readIntRequired(scanner, "Order ID to view: ");
                    Order o = controller.getOrderById(id);
                    printHeader();
                    if (o != null) printRow(o);
                    else System.out.println("| \tNot found\t\t\t\t|");
                    printFooter();
                } else if (choice == 0) {
                    break;
                } else {
                    System.out.println("Invalid option.");
                }
            } catch (IllegalArgumentException iae) {
                System.out.println("Invalid value: " + iae.getMessage());
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
            }
        }
    }

    private static Integer readIntOptional(Scanner scanner, String prompt) {
        System.out.print(prompt);
        String s = scanner.nextLine().trim();
        if (s.isEmpty()) return null;
        return Integer.parseInt(s);
    }

    private static int readIntRequired(Scanner scanner, String prompt) {
        System.out.print(prompt);
        String s = scanner.nextLine().trim();
        return Integer.parseInt(s);
    }

    private static Order buildOrder(Integer id, Date date, Integer customerId, String status) {
        try {
            // try constructors first (best-effort)
            for (var ctor : Order.class.getDeclaredConstructors()) {
                Class<?>[] pts = ctor.getParameterTypes();
                Object[] args = new Object[pts.length];
                boolean ok = true;
                for (int i = 0; i < pts.length; i++) {
                    Class<?> p = pts[i];
                    if ((p == int.class || p == Integer.class)) {
                        if (id != null) args[i] = id;
                        else { ok = false; break; }
                    } else if (p == Date.class || p == java.util.Date.class) {
                        args[i] = date;
                    } else if (p == String.class) {
                        // prefer status for string params or fall back to empty
                        args[i] = status != null ? status : "";
                    } else {
                        ok = false;
                        break;
                    }
                }
                if (!ok) continue;
                ctor.setAccessible(true);
                @SuppressWarnings("unchecked")
                Order inst = (Order) ctor.newInstance(args);
                return inst;
            }

            // fallback: no-arg + setters/fields
            Order inst = Order.class.getDeclaredConstructor().newInstance();
            if (id != null) trySet(inst, "setOrderId", id);
            trySet(inst, "setId", id);
            trySet(inst, "setOrderDate", date);
            trySet(inst, "setDate", date);
            trySet(inst, "setCustomerId", customerId);
            trySet(inst, "setOrderCustomerId", customerId);
            trySet(inst, "setStatus", status);
            trySet(inst, "setOrderStatus", status);
            return inst;
        } catch (Exception e) {
            return null;
        }
    }

    private static void trySet(Object obj, String setterName, Object value) {
        if (obj == null || value == null) return;
        Class<?> cls = obj.getClass();
        try {
            Method m = cls.getMethod(setterName, value.getClass());
            m.invoke(obj, value);
            return;
        } catch (Exception ignored) { }
        try {
            // common conversions
            if (value instanceof Integer) {
                Method m = cls.getMethod(setterName, int.class);
                m.invoke(obj, ((Integer) value).intValue());
                return;
            } else if (value instanceof Date) {
                try {
                    Method m = cls.getMethod(setterName, Date.class);
                    m.invoke(obj, value);
                    return;
                } catch (Exception ex) {
                    Method m2 = cls.getMethod(setterName, java.util.Date.class);
                    m2.invoke(obj, value);
                    return;
                }
            } else {
                Method m = cls.getMethod(setterName, String.class);
                m.invoke(obj, String.valueOf(value));
                return;
            }
        } catch (Exception ignored) { }
        // fallback: any matching method name (case-insensitive)
        for (Method m : cls.getMethods()) {
            if (!m.getName().equalsIgnoreCase(setterName)) continue;
            Class<?>[] ps = m.getParameterTypes();
            if (ps.length != 1) continue;
            try {
                if (ps[0] == String.class) m.invoke(obj, String.valueOf(value));
                else if (ps[0] == int.class || ps[0] == Integer.class) m.invoke(obj, Integer.parseInt(String.valueOf(value)));
                else if (ps[0] == Date.class || ps[0] == java.util.Date.class) m.invoke(obj, value);
                else m.invoke(obj, value);
                return;
            } catch (Exception ignored) { }
        }
        // last resort: try direct field set
        String fieldName = setterName;
        if (fieldName.startsWith("set")) {
            fieldName = Character.toLowerCase(fieldName.charAt(3)) + fieldName.substring(4);
        }
        try {
            Field f = cls.getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(obj, value);
        } catch (Exception ignored) { }
    }

    private static void printHeader() {
        System.out.println("+------------+-----------------+-------------------+-------------------+");
        System.out.println("| Order ID   | Order Date      | Order Customer ID | Order Status      |");
        System.out.println("+------------+-----------------+-------------------+-------------------+");
    }

    private static void printFooter() {
        System.out.println("+------------+-----------------+-------------------+-------------------+");
    }

    private static void printRow(Order o) {
        String id = safeGet(o, "getOrderId", "getId", "orderId", "id");
        String date = safeGet(o, "getOrderDate", "getDate", "orderDate", "date");
        String cust = safeGet(o, "getCustomerId", "getOrderCustomerId", "customerId", "orderCustomerId");
        String status = safeGet(o, "getStatus", "getOrderStatus", "status");
        System.out.format("| %-10s | %-15s | %-17s | %-17s |%n",
                emptyTo(id), emptyTo(date), emptyTo(cust), emptyTo(status));
    }

    private static String emptyTo(String s) {
        return s == null ? "" : s;
    }

    private static String safeGet(Object obj, String... candidates) {
        if (obj == null) return "";
        Class<?> cls = obj.getClass();
        // try getters
        for (String name : candidates) {
            try {
                if (name.startsWith("get")) {
                    Method m = cls.getMethod(name);
                    Object v = m.invoke(obj);
                    if (v != null) return String.valueOf(v);
                }
            } catch (Exception ignored) { }
        }
        // try direct methods/fields
        for (String name : candidates) {
            try {
                Method m = cls.getMethod(name);
                Object v = m.invoke(obj);
                if (v != null) return String.valueOf(v);
            } catch (Exception ignored) { }
        }
        for (String name : candidates) {
            String fieldName = name;
            if (fieldName.startsWith("get")) {
                fieldName = Character.toLowerCase(fieldName.charAt(3)) + fieldName.substring(4);
            }
            try {
                Field f = cls.getDeclaredField(fieldName);
                f.setAccessible(true);
                Object v = f.get(obj);
                if (v != null) return String.valueOf(v);
            } catch (Exception ignored) { }
        }
        return "";
    }
}