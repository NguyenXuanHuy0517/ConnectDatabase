package menu;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Scanner;

public final class MenuUtils {
    private MenuUtils() { /* utility */ }

    public static void trySet(Object obj, String setterName, Object value) {
        if (obj == null || value == null) return;
        Class<?> cls = obj.getClass();
        try {
            Method m = cls.getMethod(setterName, value.getClass());
            m.invoke(obj, value);
            return;
        } catch (Exception ignored) { }
        try {
            if (value instanceof Integer) {
                Method m = cls.getMethod(setterName, int.class);
                m.invoke(obj, ((Integer) value).intValue());
                return;
            }
            Method m = cls.getMethod(setterName, String.class);
            m.invoke(obj, String.valueOf(value));
            return;
        } catch (Exception ignored) { }
        for (Method m : cls.getMethods()) {
            if (!m.getName().equalsIgnoreCase(setterName)) continue;
            Class<?>[] ps = m.getParameterTypes();
            if (ps.length != 1) continue;
            try {
                if (ps[0] == String.class) m.invoke(obj, String.valueOf(value));
                else if (ps[0] == int.class || ps[0] == Integer.class) m.invoke(obj, Integer.parseInt(String.valueOf(value)));
                else m.invoke(obj, value);
                return;
            } catch (Exception ignored) { }
        }
        // fallback: set field directly
        String fieldName = setterName;
        if (fieldName.startsWith("set") && fieldName.length() > 3) {
            fieldName = Character.toLowerCase(fieldName.charAt(3)) + fieldName.substring(4);
        }
        try {
            Field f = cls.getDeclaredField(fieldName);
            f.setAccessible(true);
            if (f.getType() == int.class || f.getType() == Integer.class) {
                f.set(obj, Integer.parseInt(String.valueOf(value)));
            } else if (f.getType() == String.class) {
                f.set(obj, String.valueOf(value));
            } else {
                f.set(obj, value);
            }
        } catch (Exception ignored) { }
    }

    public static <T> T tryConstructWithAny(Class<T> cls, Object... values) {
        try {
            for (Constructor<?> ctor : cls.getDeclaredConstructors()) {
                Class<?>[] pts = ctor.getParameterTypes();
                Object[] args = new Object[pts.length];
                boolean ok = true;
                for (int i = 0; i < pts.length; i++) {
                    Class<?> p = pts[i];
                    Object pick = i < values.length ? values[i] : null;
                    if (pick == null) { ok = false; break; }
                    if (p == int.class || p == Integer.class) {
                        if (pick instanceof Number) args[i] = ((Number) pick).intValue();
                        else {
                            try { args[i] = Integer.parseInt(String.valueOf(pick)); }
                            catch (Exception ex) { ok = false; break; }
                        }
                    } else if (p == String.class) {
                        args[i] = String.valueOf(pick);
                    } else {
                        ok = false;
                        break;
                    }
                }
                if (!ok) continue;
                ctor.setAccessible(true);
                @SuppressWarnings("unchecked")
                T inst = (T) ctor.newInstance(args);
                return inst;
            }
        } catch (Exception ignored) { }
        return null;
    }

    public static String safeGetValue(Object obj, String... candidates) {
        if (obj == null) return "";
        Class<?> cls = obj.getClass();
        // try getters first
        for (String name : candidates) {
            try {
                if (name.startsWith("get")) {
                    Method m = cls.getMethod(name);
                    Object v = m.invoke(obj);
                    if (v != null) return String.valueOf(v);
                }
            } catch (Exception ignored) { }
        }
        // try direct methods
        for (String name : candidates) {
            try {
                Method m = cls.getMethod(name);
                Object v = m.invoke(obj);
                if (v != null) return String.valueOf(v);
            } catch (Exception ignored) { }
        }
        // try fields
        for (String name : candidates) {
            String fieldName = name;
            if (fieldName.startsWith("get") && fieldName.length() > 3) {
                fieldName = Character.toLowerCase(fieldName.charAt(3)) + fieldName.substring(4);
            }
            try {
                Field f = cls.getDeclaredField(fieldName);
                f.setAccessible(true);
                Object v = f.get(obj);
                if (v != null) return String.valueOf(v);
            } catch (Exception ignored) { }
        }
        return "";
    }

    public static String emptyTo(String s) {
        return (s == null || s.isEmpty()) ? "-" : s;
    }

    public static int readIntRequired(Scanner scanner, String prompt) {
        while (true) {
            System.out.print(prompt);
            String line = scanner.nextLine().trim();
            try {
                return Integer.parseInt(line);
            } catch (NumberFormatException e) {
                System.out.println("Invalid number. Try again.");
            }
        }
    }

    public static String truncate(String s, int max) {
        if (s == null) return "";
        return s.length() > max ? s.substring(0, max) : s;
    }
}