
package menu;

import controller.CustomerController;
import model.Customer;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Scanner;

public class CustomerMenu {
    public static void customerMenu(Scanner scanner) {
        CustomerController controller = new CustomerController();

        while (true) {
            System.out.println("\n=== Customer menu ===");
            System.out.println("1. Add Customer");
            System.out.println("2. Update Customer");
            System.out.println("3. Delete Customer");
            System.out.println("4. View Customers");
            System.out.println("5. View Customer by ID");
            System.out.println("0. Back");
            System.out.print("Choose an option: ");

            String line = scanner.nextLine().trim();
            int choice;
            try {
                choice = Integer.parseInt(line);
            } catch (Exception e) {
                System.out.println("Invalid input.");
                continue;
            }

            try {
                if (choice == 1) {
                    Customer c = buildCustomerFromInput(scanner);
                    if (c != null) {
                        boolean ok = controller.insertCustomer(c);
                        System.out.println(ok ? "Added successfully." : "Add failed.");
                    } else {
                        System.out.println("Cannot create Customer object.");
                    }
                } else if (choice == 2) {
                    System.out.print("Customer ID to update: ");
                    int id = Integer.parseInt(scanner.nextLine().trim());
                    Customer c = buildCustomerFromInput(scanner);
                    if (c != null) {
                        // Ensure id set
                        trySet(c, "setCustomerId", id);
                        trySet(c, "setId", id);
                        boolean ok = controller.updateCustomer(c);
                        System.out.println(ok ? "Updated successfully." : "Update failed.");
                    } else {
                        System.out.println("Cannot create Customer object.");
                    }
                } else if (choice == 3) {
                    System.out.print("Customer ID to delete: ");
                    int id = Integer.parseInt(scanner.nextLine().trim());
                    boolean ok = controller.deleteCustomer(id);
                    System.out.println(ok ? "Deleted successfully." : "Delete failed.");
                } else if (choice == 4) {
                    List<Customer> list = controller.getAllCustomers();
                    printHeader();
                    if (list != null) {
                        for (Customer cc : list) printCustomerRow(cc);
                    }
                    printFooter();
                } else if (choice == 5) {
                    System.out.print("Customer ID to view: ");
                    int id = Integer.parseInt(scanner.nextLine().trim());
                    Customer cc = controller.getCustomerById(id);
                    printHeader();
                    if (cc != null) printCustomerRow(cc);
                    else System.out.println("| \tNot found\t\t\t\t\t|");
                    printFooter();
                } else if (choice == 0) {
                    break;
                } else {
                    System.out.println("Invalid option.");
                }
            } catch (NumberFormatException nfe) {
                System.out.println("Invalid number format.");
            } catch (Exception e) {
                System.out.println("Error: " + e.getMessage());
            }
        }
    }

    private static Customer buildCustomerFromInput(Scanner scanner) {
        try {
            System.out.print("Customer ID (leave blank if none): ");
            String idLine = scanner.nextLine().trim();
            Integer id = null;
            if (!idLine.isEmpty()) id = Integer.parseInt(idLine);

            System.out.print("Customer Name: ");
            String name = scanner.nextLine();
            System.out.print("Customer Email: ");
            String email = scanner.nextLine();
            System.out.print("Customer Phone: ");
            String phone = scanner.nextLine();
            System.out.print("Customer Address: ");
            String address = scanner.nextLine();

            // instantiate via no-arg constructor if available
            Customer c;
            try {
                c = Customer.class.getDeclaredConstructor().newInstance();
            } catch (Exception ex) {
                // fallback: try to find any constructor that accepts strings/ints (best-effort)
                c = tryConstructWithAny(Customer.class, id, name, email, phone, address);
                if (c == null) return null;
            }

            if (id != null) {
                trySet(c, "setCustomerId", id);
                trySet(c, "setId", id);
            }
            trySet(c, "setCustomerName", name);
            trySet(c, "setName", name);
            trySet(c, "setEmail", email);
            trySet(c, "setEmailAddress", email);
            trySet(c, "setPhone", phone);
            trySet(c, "setPhoneNumber", phone);
            trySet(c, "setAddress", address);
            trySet(c, "setCustomerAddress", address);

            return c;
        } catch (Exception e) {
            return null;
        }
    }

    private static <T> T tryConstructWithAny(Class<T> cls, Integer id, String... strs) {
        try {
            for (var ctor : cls.getDeclaredConstructors()) {
                Class<?>[] ptypes = ctor.getParameterTypes();
                Object[] args = new Object[ptypes.length];
                boolean ok = true;
                for (int i = 0; i < ptypes.length; i++) {
                    Class<?> p = ptypes[i];
                    if ((p == int.class || p == Integer.class) && id != null) args[i] = id;
                    else if (p == String.class) {
                        int sidx = i - (ptypes.length - strs.length);
                        // choose from provided strings in order, clamp index
                        int pick = Math.max(0, Math.min(strs.length - 1, i));
                        args[i] = strs[pick];
                    } else {
                        ok = false;
                        break;
                    }
                }
                if (!ok) continue;
                ctor.setAccessible(true);
                @SuppressWarnings("unchecked")
                T inst = (T) ctor.newInstance(args);
                return inst;
            }
        } catch (Exception ignored) {
        }
        return null;
    }

    private static void trySet(Object obj, String setterName, Object value) {
        if (obj == null || value == null) return;
        Class<?> cls = obj.getClass();
        try {
            Method m = cls.getMethod(setterName, value.getClass());
            m.invoke(obj, value);
            return;
        } catch (Exception ignored) {
        }
        try {
            if (value instanceof Integer) {
                Method m = cls.getMethod(setterName, int.class);
                m.invoke(obj, ((Integer) value).intValue());
                return;
            }
            if (value instanceof String) {
                Method m = cls.getMethod(setterName, String.class);
                m.invoke(obj, value);
                return;
            }
        } catch (Exception ignored) {
        }
        for (Method method : cls.getMethods()) {
            if (!method.getName().equalsIgnoreCase(setterName)) continue;
            Class<?>[] ps = method.getParameterTypes();
            if (ps.length != 1) continue;
            try {
                if (ps[0] == String.class) method.invoke(obj, String.valueOf(value));
                else if (ps[0] == int.class || ps[0] == Integer.class) method.invoke(obj, Integer.parseInt(String.valueOf(value)));
                else method.invoke(obj, value);
                return;
            } catch (Exception ignored) {
            }
        }
    }

    private static void printHeader() {
        System.out.println("+------------+----------------------+----------------------+----------------------+");
        System.out.println("| CustomerID | CustomerName         | Email                | Phone                |");
        System.out.println("+------------+----------------------+----------------------+----------------------+");
    }

    private static void printFooter() {
        System.out.println("+------------+----------------------+----------------------+----------------------+");
    }

    private static void printCustomerRow(Customer c) {
        String id = safeGetValue(c, "getCustomerId", "getId", "customerId", "id");
        String name = safeGetValue(c, "getCustomerName", "getName", "name");
        String email = safeGetValue(c, "getEmail", "getEmailAddress", "email");
        String phone = safeGetValue(c, "getPhone", "getPhoneNumber", "phone");

        if (name == null) name = "";
        if (email == null) email = "";
        if (phone == null) phone = "";
        if (id == null) id = "";

        String tn = name.length() > 20 ? name.substring(0, 20) : name;
        String te = email.length() > 20 ? email.substring(0, 20) : email;
        String tp = phone.length() > 20 ? phone.substring(0, 20) : phone;

        System.out.format("| %-10s | %-20s | %-20s | %-20s |%n", id, tn, te, tp);
    }

    private static String safeGetValue(Object obj, String... candidates) {
        if (obj == null) return "";
        Class<?> cls = obj.getClass();

        // try getters
        for (String name : candidates) {
            try {
                if (name.startsWith("get")) {
                    Method m = cls.getMethod(name);
                    Object v = m.invoke(obj);
                    if (v != null) return String.valueOf(v);
                }
            } catch (Exception ignored) {
            }
        }

        // try direct named methods
        for (String name : candidates) {
            try {
                Method m = cls.getMethod(name);
                Object v = m.invoke(obj);
                if (v != null) return String.valueOf(v);
            } catch (Exception ignored) {
            }
        }

        // try fields
        for (String name : candidates) {
            String fieldName = name;
            if (fieldName.startsWith("get")) {
                fieldName = Character.toLowerCase(fieldName.charAt(3)) + fieldName.substring(4);
            }
            try {
                Field f = cls.getDeclaredField(fieldName);
                f.setAccessible(true);
                Object v = f.get(obj);
                if (v != null) return String.valueOf(v);
            } catch (Exception ignored) {
            }
        }

        return "";
    }
}